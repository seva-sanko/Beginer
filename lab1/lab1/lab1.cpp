#include <cmath>			// математические функции
#include <locale.h>	// функции, устанавливающие национальные кодировки символов
#include <iostream>	// Эта - часть библиотеки STL (Standard Template Library)
#include <limits>			// Полезные константы

using namespace std;		// Обеспечивает видимость имен STL
//#define stop __asm nop


#ifdef ENABLE_ASM_NOP // Проверяем, определен ли флаг ENABLE_ASM_NOP

#define stop __asm nop// Эта макроподстановка упрощает установку точек останова

#else // Если флаг не определен, определяем stop как комментарий

#define stop // Оставляем stop пустым

#endif

int n;	 // Глобальная переменная. По умолчанию она обнуляется.

namespace space	 // В пространстве имен - space
{
	int n = 1;	 // Объявлена переменная n
}				 // space определяет область видимости этой переменной

int  main()
{
	setlocale(LC_ALL, "rus");
	// Выполняя программу по шагам, следите за значениями переменных  и интерпретируйте результат, объясняя себе
	// наблюдаемые значения. Обратите внимание на разную интерпретацию отладчиком  signed и unsigned типов данных.
	char c = 'A'; // 65 'A' 0x41 
	// В комментарии справа полезно проставить десятичное символьное и шестнадцатиричное 
	// значения переменной после выполнения указанной строки. Вы должны видеть их в окне Autos.
	c = 0x42;		// 66 'B' 0x42
	c = -1;		// -1 'я' 0xff
	c = CHAR_BIT;	 // Размер переменной типа char
	stop;

	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';//1060
	size_t ns = sizeof(cw);//(2 байта = 16 бит) 32 бита

	unsigned char uc = 0x41;
	uc = 'B';
	uc = -1;
	stop;

	int i = 1;
	i = -1;
	stop;

	unsigned int ui = 1;
	ui = -1;

	unsigned short s = 0xffff;	 // *Здесь compiler генерирует warning. Измените код, чтобы убрать warning
	//short s = 0xffff; -> unsigned short s = 0xffff;
	s = short(0xffff);//unsigned short
	s = 1;

	//==== Измените код, чтобы убрать warning
	unsigned short us = 0xffff;
	us = 5;

	long l = 0xffffffff;//-1
	l = -128;

	// Все эти константы вы должны найти в файле limits (float.h) и объяснить их смысл по комментариям

	l = FLT_MAX_EXP;	// Максимальное значение экспоненты для float 128
	l = DBL_MAX_EXP;    // Максимальное значение экспоненты для double 1024

	l = FLT_MANT_DIG;   //Этот макрос представляет количество значащих битов в мантисс(24)
	l = DBL_DIG;    //Этот макрос представляет десятичное количество значащих цифр, которые можно представить в типе double(15)

	l = FLT_MANT_DIG;   // Количество значащих битов мантиссы для float 24
	l = DBL_MANT_DIG;   // Количество значащих битов мантиссы для double 53


	float f = -12.56f;	 //float f = -12.56; -> float f = -12.56f;   *Здесь warning. Уберите его.
	f = -1.e-27f;

	f = FLT_MAX;  //Максимальное значение переменной типа float 3.40282347e+38
	f = FLT_MIN;  //Минимальное значение переменной типа float 1.17549435e-38


	double d = 0.1234567890123456789123456789; //0.12345678901234567891234568 округление
	d = -0.123456789012345e+306;
	d = DBL_MAX; // Максимальное значение double   1.7976931348623157e+308	
	d = DBL_MIN; // Минимальное положительное значение double   2.2250738585072014e-308
	d = DBL_EPSILON;// Самая маленькая разность между двумя пер-ми типа double 2.2250738585072014e-308

	// Побитовое отрицание

	uc = ~0;//Все 0 меняются на 1, а значит uc будет максимально большого значения типа unsigned char 255  		 
	i = ~0;//аналогично -1 
	stop;

	// Раннее (при компиляции) или неявное приведение типов данных
	// Объясните те значения, которые вы наблюдаете в окне Autos. Определите порядок выполения присваиваний.
	d = f = i = s = c = 1 / 3;//char short int float double 0->0->0->0.->0.
	c = s = i = f = d = 100 / 3;//33.(3)->33.0->33.0->33->33
	c = s = i = f = d = 10 / 3;// 3.33->3.33->3->3->3
	c = s = i = f = d = 1 / 3.;//0.33..1->0.33-> 0->0

	// Пример "небрежного" использования неявного приведения типов.	 Объясните результаты.
	i = 256;
	c = i;// c char поэтому после присваивания 256 мы выйдем за границу и окажемся в 0

	uc = 255;
	unsigned char u = 2, sum = uc + u;// sum unsigned char [0;255] => 255 + 2 = 0 + 1 = 1 
	stop;

	// Явное приведение типов	Объясните разницу результатов в строках (3) и (4)
	i = 100;
	f = d = i / 3;	// 33.0 -> 33.0 						// (3) 
	f = d = (double)i / 3;		// явное приведение поэтому 100.0 / 3 = 33.(3) (4)
	f = d = double(i) / 3;			// аналогично, результат будет таким же(4)
	f = d = static_cast<double>(i) / 3;		// еще один способ явного приведения(4)
	stop;

	// Область действия, область видимости и время существования. В этом фрагменте фигурируют четыре
	//  переменных с одним и тем же именем n.  Одна - глобальная, вторая определена в своем пространстве имен,
	// третья - локальная внутри функции main(), четвертая - локальная внутри блока. 
	//  Обратите внимание, что глобальная переменная и та, что в пространстве имен space - объявлены вне функции main()
	// Определите, к какой из четырех переменных идет обращение, cформулируйте область действия и область видимости
	// каждой переменной. Для выполнения задания рекомендуется пользоваться  закладкой "Watches" или "Locals" окна
	// "Autos". Подсказка: В окно "Watches" можно поместить сразу все переменные (n, ::n, и space::n)
	n = 100;
	space::n = 200;
	n++;//101
	int n;	//локальная живет в пределах main	//Где живет эта переменная ?
	n = 10;
	::n++;//102

	{				//  Начало блока
		int n;		// Эта переменная живет внутри блока
		n = -1;
		n++;//0
		::n++;//103
		space::n++;//201
	}		// Конец блока
	n--;//10
	::n--;//102
	space::n--;//200

	// Спецификатор класса памяти - static Выполняя задание по шагам, обратите внимание на  разное поведение
	// переменных nLoc и nStat
	{
	Again:
		int outer;
		for (int i = 0; i < 5; i++)
		{
			static int nStat;//статическая внутри блока for, доступна после завершенияя цикла в пределах блока Again
			{
				int nLoc = 0;//обычная локальная переменная, существует в пределах блока
				nLoc++;		nStat++;
			}
			outer = nStat;
		}
		if (outer < 10)
			goto Again;
	}
	// Перечисления - enum. Обратите внимание на явную и неявную инициализацию констант
	enum RANK
	{
		One,//0
		Two,//1
		Three,//2
		Four,//3
		Jack = 6,//6
		Queen,//7
		Ace = Queen + 3,//10
		Joker = 20//20
	};
	typedef RANK RANG;

	RANG r = Jack;//6
	if (r == Jack)
		r = Queen;//7

	if (r == Queen)
	{
		// Любой целочисленной переменной можно присвоить enum-переменную 
		int i = r;
		r = RANK(i++);//7		// Обратное преобразование надо указывать явно
		i = r;//7
		r = RANK(++i);//8
		i = r;//8
	}
	RANK rr = Ace;//10
	stop;
	//	Логический тип bool.	Выполняя задание по шагам, следите за значениями переменной b
	{
		int n = 127;
		bool b = n != 0;//true
		b = n == 0;//false
		b = n > 0;//true
		b = n <= 0;//false
		b = n > 1;//true

		int num = static_cast<int>(b);//1
		if (b)
			cout << "\n\t My flag is: true" << "   or: " << b
			<< "\n\t Conversion to int: " << num << endl;
		b = n == num;//false
		cout << "\n\t Now the flag is: false" << "   or: " << b;
	}

	//	Модификатор const
	const double pi = acos(-1.);
	double space_permiability = 4.e-7 * pi;		//	Магнитная проницаемость пустоты
	const int dozen = 12;
	int var = dozen;//12

	//	Раскомментируйте следующую строчку и объясните ошибку компиляции (l-value означает left value)
	//	dozen = 1;
	//	Директивы условной трансляции. Объясните значение, которое принимает переменная version.
	//	Что нужно сделать для того, чтобы результат был другим?
#define _MSVER400
	const char* version;
#if defined _MSVER400//если эта версия строке присвоится значение ниже
	version = "version 4.00";
#elif defined _MSVER311// если эта версия то присвоится строка ниже
	version = "version 3.11";
#else//в ином случае присвоится последняя строка
	version = "version Unknown";
#endif

	cout << endl << version;
	stop;

	//В окне ClassView или Solution Explorer поставьте фокус на имя проекта дайте команду Project/Properties.
	//	В диалоге Property Pages щелкните на папке Configuration Properties, убедитесь, что в разделе Code Generation
	//	установлена константа компиляции _DEBUG. Создайте директивы препроцессора и код С++, которые
	//	в зависимости от действующей конфигурации проекта (_DEBUG или NDEBUG) выводят соответствующее
	//	сообщение. Измените конфигурацию проекта (в диалоге Property Pages) и проверьте ваш код.
	//	Чтобы изменить конфигурацию пользуйтесь кнопкой Configuration Manager

	//	Простейшие циклы. Объясните суть происходящего. 
	{
		// Цикл while надо использовать, когда неизвестно количество итераций (повторений) цикла.
		cout << "\n\nGradually eat out all the units:\n\n";
		unsigned short us = 0xff;
		while (us)
		{
			cout << hex << us << endl; //снимается младший установленный бит
			us &= us - 1;
		}
		cout << hex << us << "\nDone\n";
		// Цикл for надо использовать, когда известно количество итераций и/или есть код подготовки.
		// Подсказка: odd - нечетое, even - четное.
		cout << "\n\nShow even-odd:\n\n";
		for (int i = 0; i < 10; i++)
		{
			if (i & 1)
				cout << i << " - odd\n";
			else
				cout << i << " - even\n";
		}
		// Когда нужно использовать цикл do-while?
		char c = ' ';
		do
		{
			if (c == 'a')
				cout << "\nAction is a delegate type in C#";
			else if (c == 'b')
				cout << "\nbreak is one of the 'leave' statements in all C-like languages";
			else if (c == 'c')
				cout << "\ncontinue is a 'go on' statement in all C-like languages";
			else if (c == 'd')
				cout << "\ndo-while is a rarely used loop statement in all C-like languages";
			else
				cout << "\nPlease read the rules of this loop";
			cout << "\n\nEnter chars: a, b, c, d (q - to quit):\n\n";
			cin >> c;
			if (c == 'q')
				cout << "\nI am going to leave the loop\n";
		} while (c != 'q');
		stop;
	}
	//	Логические условные операторы и циклы. Функция y = f(x) задана графиком
	//	Напишите фрагмент кода, который с шагом 0.1 вычисляет y = f(x)  и выводит в консольное окно значения x и y. 
	//	  y
	//	  | 
	//	 2|__________
	//	  |         /\
	//	  |        /  \
	//	  |       /    \
	//	  |______/      \__________  x
	//	  0      1   2   3
	//	 Реалируйте 2 варианта этого алгоритма:   1. Используйте операторы if	 2. Используйте тернарные операции    ? :

	double y = 0.0;
	double x = 0.0;
	int Y = 0;
	for (x = 0.0; x < 4.0; x += 0.1) {
		if (x >= 0.0 && x < 1.0) {
			y = 0.0;
			cout << "x: " << x << " y: " << y << endl;
		}
		else if (x >= 1.0 && x <= 2.0) {
			y += 0.2;
			cout << "x: " << x << " y: " << y << endl;
			while (y <= 1.9) { // должно быть <= однако из-за арифметических ошибок при последнем заходе значение меньше двух а не равно двум
				x += 0.1;
				y += 0.2;
				//Y = (int)y;
				cout << "x: " << x << " y: " << y << endl;
			}			
		}
		else if (x > 2.0 && x <= 3.0) {
			y -= 0.2;
			cout << "x: " << x << " y: " << y << endl;
			while (y > 0.22) {//нужно было бы использовать >= объяснение см. ниже
				x += 0.1;
				y -= 0.2;
				cout << "x: " << x << " y: " << y << endl;
			}
			x += 0.1;
			y = 0.0;//из-за ошибок округления получается очень маленькое значение близкое к нулю, для этого нужна эта строка
			cout << "x: " << x << " y: " << y << endl;
		}
		else {
			y = 0.0;
			cout << "x: " << x << " y: " << y << endl;
		}
	}


	cout << endl << "Other variant:" << endl << endl;

	for (x = 0; x < 4; x += 0.1) {
		y = (x >= 0 && x < 1) ? 0 :
			(x >= 1 && x <= 2.1) ? (y <= 2 ? y + 0.2 : y) :
			(x > 2.1 && x <= 3) ? (y >= 0 ? y - 0.2 : y) : 0;
		cout << " x: " << x << " y: " << y << endl;
	}


	//	Напишите фрагмент, который с помощью for и switch реализует следующую логику. Если пользователь ввел:
	//	символ 'a',   ваш алгоритм выводит  "Ok" (в кавычках)
	//	символ 'b',   ваш алгоритм выводит  Bell (alert - звуковой сигнал)
	//	символ 'с',   ваш алгоритм выводит  число, которое равно количеству введенных символов
	//	символ 'Esc', ваш алгоритм выводит  "to quit use 'q'"
	//	символ 'q',   ваш алгоритм выводит  "Bye" и выходит из цикла ввода

	char input;
	int count = 0;
	bool shouldExit = false; // Флаг для выхода из цикла

	cout << endl;
	for (;;) { // Бесконечный цикл
		cout << "Enter the symbol (a, b, c, !, q): ";
		cin >> input;

		switch (input) {
		case 'a':
			cout << "Ok" << endl;
			break;
		case 'b':
			cout << '\a'; // Проиграть звуковой сигнал (звонок)
			break;
		case 'c':
			cout << "Number of symbols: " << count << endl;
			break;
		case 33: // ASCII-код для !
			cout << "To quit, click 'q'" << endl;
			break;
		case 'q':
			cout << "Bye!" << endl;
			shouldExit = true; // Устанавливаем флаг выхода
			break;
		default:
			cout << "Unknown symbol" << endl;
		}

		count++; // Увеличение счетчика символов

		if (shouldExit) {
			break; // Выходим из цикла при установленном флаге
		}
	}

	//	Побитовые операции:  |, &, ~, ^ и сдвиги >>, <<
	//	Поменяйте местами байты переменной flags и выведите результат в консолное окно unsigned short flags = 0xaabb;
	//	Ваш код

	cout << endl;
	unsigned short flags = 0xaabb;

	// Поменяем местами байты
	unsigned short swapped_flags = ((flags >> 8) & 0x00FF) | ((flags << 8) & 0xFF00);

	cout << hex << "flags: 0x" << flags << endl;
	cout << hex << "swappted flags : 0x" << swapped_flags << endl;
	cout << hex << flags << endl << dec << flags << endl;

	//	Для вывода в шестнадцатеричном виде используйте  cout <<"\n bits = " << hex << flags;
	//	В переменной unsigned char byte = 0x26; 
		//      - установите в единицу 3-й бит (счет от нуля). Выведите результат.
	//	- инвертируйте два младших бита. Выведите результат. 
		//      - обнулите 4 младших бита. Выведите результат.
	//	cout <<endl << hex << flags << endl<<dec<<flags;    

	cout << endl;
	unsigned char byte = 0x26;

	// Установить в единицу 3-й бит
	byte |= (1 << 3);
	cout << "Установлен 3-й бит: " << hex << (int)byte << endl;

	// Инвертировать два младших бита
	byte ^= 0x03;
	cout << "Инвертированы два младших бита: " << hex << (int)byte << endl;

	// Обнулить 4 младших бита
	byte &= 0xF0;
	cout << "Обнулены 4 младших бита: " << hex << (int)byte << endl;

	cout << "\n\n";
}	// Конец функции main()
